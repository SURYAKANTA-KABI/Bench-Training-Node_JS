SRING CORE::--

1:-What is Spring Framework? 
Ans:-It is a loosely coupled and integrated framework for developing java applications smoothly.

2:-What are the advantages of Spring Framework?
Ans:-a:(Predefined Templates)--Spring framework provides templates for JDBC, Hibernate, JPA etc. technologies. So there is no need to write too much code.
       It hides the basic steps of these technologies.
     b:(Loose coupling)--The Spring applications are loosely coupled because of dependency injection.
     c:(Easy to test)--The Dependency Injection makes easier to test the application. 
       The Struts application require server to run the application but Spring framework doesn't require server.
     d:(Lightweight)--Spring framework is lightweight because of its POJO implementation.
       The Spring Framework doesn't force the programmer to inherit any class or implement any interface.
       That is why it is said non-invasive.
    e:(Fast Development)--The Dependency Injection feature of Spring Framework and it support to various frameworks makes the easy development of Java application.
4:-What is Dependancy injection in spring?
Ans:-this allows for loose coupling of objects and moves the responsibility of managing objects onto the container(IOC).

5:-What are modules in Spring Framework? 
Ans:-Test
     Spring Core Container
     AOP, Aspects and Instrumentation
     Data Access/Integration
     Web

6:-What is IOC and DI?
Ans:-IOC (Inversion of Control) and DI (Dependency Injection) is a design pattern to provide loose coupling. It removes the dependency from the program.

7:-What is the role of IOC container in spring?
Ans:-The IoC container is responsible to create, configure and assemble the objects. The IoC container gets informations from the XML file and works accordingly. 

8:-What are the types of IOC container in spring?
Ans:-BeanFactory
     ApplicationContext

9:What is the Difference between BeanFactory and the ApplicationContext?
Ans:-The main difference is ApplicationContext It adds some extra functionality than BeanFactory such as simple integration with Spring's AOP,application layer specific context (e.g. WebApplicationContext) for web application. 
     So it is better to use ApplicationContext than BeanFactory.
     ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");  

10:-What is Spring AOP? 
Ans:-AOP (aspect-oriented programming) is a programming style that enables your application to be adaptable to changes such as logging,auditing,transactions,security,caching etc.

11:-What is bean.xml? 
Ans:-A bean is an object that is created, assembled, and managed by a Spring IoC container.

12:-What is mean by Pojo? 
Ans:-POJO in Java stands for Plain Old Java Object.
     It is an ordinary object, which is not bound by any special restriction.
     It increases the readability & re-usability of a Java program.
     POJOs are now widely accepted due to their easy maintenance.
     They are easy to read and write. A POJO class does not have any naming convention for properties and methods. 
     It is not tied to any Java Framework; any Java Program can use it.

13:-What is setter injection and constructor injection? 
Ans:-Setter injection in Spring uses setter methods like setDependency() to inject dependency on any bean managed by Spring's IOC container.
     Constructor injection uses the constructor to inject dependency on any Spring-managed bean.

14:-What is the use of xsd in beans.xml file? 
Ans:-It is used to validate the proper tag in a bean.xml file and to track the Schema loaction on internet or local classpath.

15:- Constructor injection with dependent object?
Amns:-If there is HAS-A relationship between the classes, we create the instance of dependent object (contained object) first then pass it as an argument of the main class constructor.

16:Autowiring in Spring?
Ans:-Autowiring feature of spring framework enables you to inject the object dependency implicitly.
     It internally uses setter or constructor injection.
     Autowiring can't be used to inject primitive and string values. It works with reference only.

17:-Advantage of Autowiring?
Ans:-It requires the less code because we don't need to write the code to inject the dependency explicitly.

18:-Disadvantage of Autowiring?
Ans:-No control of programmer,It can't be used for primitive and string values.

19:-Autowiring Modes
Ans:-   There are many autowiring modes:
	no:-It is the default autowiring mode. It means no autowiring bydefault.
	byName:-The byName mode injects the object dependency according to name of the bean. In such case, property name and bean name must be same. It internally calls setter method.
	byType:-The byType mode injects the object dependency according to type. So property name and bean name can be different. It internally calls setter method.
	constructor:-The constructor mode injects the dependency by calling the constructor of the class. It calls the constructor having large number of parameters.

20:-Dependency Injection with Factory Method in Spring?
Ans:-Spring framework provides facility to inject bean using factory method. To do so, we can use two attributes of bean element.
     1:factory-method: represents the factory method that will be invoked to inject the bean.
     2:factory-bean: represents the reference of the bean by which factory method will be invoked. It is used if factory method is non-static.
     A method that returns instance of a class is called factory method.


SPRING BOOT::--

1:-What is Spring Boot?
Ans:-Spring Boot is a project that is built on the top of the Spring Framework.
	It provides an easier and faster way to set up, configure, and run both simple and web-based applications.
	It is a Spring module that provides the RAD (Rapid Application Development) feature to the Spring Framework. 
	It is used to create a stand-alone Spring-based application that you can just run because it needs minimal Spring configuration.
	In short, Spring Boot is the combination of Spring Framework and Embedded Servers.
	In Spring Boot, there is no requirement for XML configuration (deployment descriptor).
	It uses convention over configuration software design paradigm that means it decreases the effort of the developer.

2:-Why we use spring boot?
Ans:-We should use Spring Boot Framework because:
	The dependency injection approach is used in Spring Boot.
	It contains powerful database transaction management capabilities.
	It simplifies integration with other Java frameworks like Hibernate ORM, Struts, etc.
	It reduces the cost and development time of the application.

3:-Advantages of Spring Boot?
Ans:-It creates stand-alone Spring applications that can be started using Java -jar.
	It tests web applications easily with the help of different Embedded HTTP servers such as Tomcat, Jetty, etc. We don't need to deploy WAR files.
	It provides opinionated 'starter' POMs to simplify our Maven configuration.
	It provides production-ready features such as metrics, health checks, and externalized configuration.
	There is no requirement for XML configuration.
	It offers a CLI(Command line interface) tool for developing and testing the Spring Boot application.
	It offers the number of plug-ins.
	It also minimizes writing multiple boilerplate codes (the code that has to be included in many places with little or no alteration), XML configuration, and annotations.
	It increases productivity and reduces development time.

4:-Limitations of Spring Boot?
Ans:-Spring Boot can use dependencies that are not going to be used in the application.
     These dependencies increase the size of the application.

5:-Goals of Spring Boot?
Ans:-The main goal of Spring Boot is to reduce development, unit test, and integration test time.
	Provides Opinionated Development approach
	Avoids defining more Annotation Configuration
	Avoids writing lots of import statements
	Avoids XML Configuration.

5:-Spring Boot Features?
Ans:-   Web Development
	SpringApplication
	Application events and listeners
	Admin features
	Externalized Configuration
	Properties Files
	YAML Support
	Type-safe Configuration
	Logging
	Security


SPRING BOOT ANNOTATIONS


@Required: It applies to the bean setter method. 
           It indicates that the annotated bean must be populated at configuration time with the required property,
           else it throws an exception BeanInitilizationException.

@Autowired:In the spring boot, @Autowired annotation is used for dependency injection.
	   In spring boot application, all loaded beans are eligible for auto wiring to another bean. 
	   The annotation @Autowired in spring boot is used to auto-wire a bean into another bean.

@Bean: It is a method-level annotation. It is an alternative of XML <bean> tag. It tells the method to produce a bean to be managed by Spring Container.


@Controller: The @Controller is a class-level annotation.
             It is a specialization of @Component.
             It marks a class as a web request handler.
             It is often used to serve web pages. By default, it returns a string that indicates which route to redirect.
             It is mostly used with @RequestMapping annotation.

@Service: It is also used at class level. It tells the Spring that class contains the business logic.

@Repository: It is a class-level annotation.
             The repository is a DAOs (Data Access Object) that access the database directly.
             The repository does all the operations related to the database.

@SpringBootApplication: It is a combination of three annotations @EnableAutoConfiguration, @ComponentScan, and @Configuration.

@RequestMapping: It is used to map the web requests.
                 It has many optional elements like consumes, header, method, name, params, path, produces, and value.
                 We use it with the class as well as the method.

@GetMapping: It maps the HTTP GET requests on the specific handler method.
             It is used to create a web service endpoint that fetches .
             It is used instead of using: @RequestMapping(method = RequestMethod.GET)

@PostMapping: It maps the HTTP POST requests on the specific handler method. 
             It is used to create a web service endpoint that creates .
             It is used instead of using: @RequestMapping(method = RequestMethod.POST)

@PutMapping: It maps the HTTP PUT requests on the specific handler method. 
             It is used to create a web service endpoint that creates or updates.
             It is used instead of using: @RequestMapping(method = RequestMethod.PUT)

@DeleteMapping: It maps the HTTP DELETE requests on the specific handler method.
             It is used to create a web service endpoint that deletes a resource. 
             It is used instead of using: @RequestMapping(method = RequestMethod.DELETE)

@PatchMapping: It maps the HTTP PATCH requests on the specific handler method. 
             It is used instead of using: @RequestMapping(method = RequestMethod.PATCH)

@RequestBody: It is used to bind HTTP request with an object in a method parameter. 
             Internally it uses HTTP MessageConverters to convert the body of the request.
             When we annotate a method parameter with @RequestBody, the Spring framework binds the incoming HTTP request body to that parameter.

@ResponseBody: It binds the method return value to the response body. It tells the Spring Boot Framework to serialize a return an object into JSON and XML format.

@PathVariable: It is used to extract the values from the URI.
             It is most suitable for the RESTful web service, where the URL contains a path variable.
             We can define multiple @PathVariable in a method.

@RequestParam: It is used to extract the query parameters form the URL.
             It is also known as a query parameter.
             It is most suitable for web applications. 
             It can specify default values if the query parameter is not present in the URL.

@RequestHeader: It is used to get the details about the HTTP request headers.
             We use this annotation as a method parameter. 
             The optional elements of the annotation are name, required, value, defaultValue.
             For each detail in the header, we should specify separate annotations.
             We can use it multiple time in a method

@RestController: It can be considered as a combination of @Controller and @ResponseBody annotations.
            The @RestController annotation is itself annotated with the @ResponseBody annotation. 
            It eliminates the need for annotating each method with @ResponseBody.

@RequestAttribute: It binds a method parameter to request attribute. 
            It provides convenient access to the request attributes from a controller method. With the help of @RequestAttribute annotation, 
            we can access objects that are populated on the server-side.

@EnableEurekaClient: To enble it for the eureka server and connect all the microservices

EnableSwagger2: To enable swagger implementation for the database

EnableWebSecurity:- The @EnableWebSecurity is a marker annotation. 
		    It allows Spring to find (it's a @Configuration and, therefore, @Component ) and automatically apply the class to the global WebSecurity . 
		    If I don't annotate any of my class with @EnableWebSecurity still the application prompting for username and password.

CrossOrigin: This @CrossOrigin annotation enables cross-origin resource sharing only for this specific method. 
	     By default, its allows all origins, all headers, and the HTTP methods specified in the @RequestMapping annotation

EnableGlobalSecurity: EnableWebSecurity will provide configuration via HttpSecurity.
		      It allows you to configure your access based on urls patterns, the authentication endpoints, handlers etc...
		      EnableGlobalMethodSecurity provides AOP security on methods. 
		      Some of the annotations that it provides are PreAuthorize, PostAuthorize.For your needs, it's better to mix the two.

@Override : @Override annotation informs the compiler that the element is meant to override an element declared in a superclass. 

JUNIT 5 ANNOTATIONS:-

Assert:-

void assertEquals(boolean expected,boolean actual): checks that two primitives/objects are equal. It is overloaded.
void assertTrue(boolean condition): checks that a condition is true.
void assertFalse(boolean condition): checks that a condition is false.
void assertNull(Object obj): checks that object is null.
void assertNotNull(Object obj): checks that object is not null.

1:-@Test
@Test annotation specifies that method is the test method.

2:-@Mock
We can use @Mock to create and inject mocked instances without having to call Mockito.mock manually.

3:-InjectMock
@InjectMocks is the Mockito Annotation. It allows you to mark a field on which an injection is to be performed.

